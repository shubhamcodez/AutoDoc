import { ZodSchema } from 'zod';

/**
 * @public
 */
declare interface BackendNotification {
    title: string;
    description?: string;
    noAutoDismiss?: boolean;
}

/** @public */
export declare interface BaseLoadModelOpts<TLoadModelConfig> {
    /**
     * The identifier to use for the loaded model.
     *
     * By default, the identifier is the same as the path (1st parameter). If the identifier already
     * exists, a number will be attached. This option allows you to specify the identifier to use.
     *
     * However, when the identifier is specified and it is in use, an error will be thrown. If the
     * call is successful, it is guaranteed that the loaded model will have the specified identifier.
     */
    identifier?: string;
    /**
     * The configuration to use when loading the model.
     */
    config?: TLoadModelConfig;
    /**
     * An `AbortSignal` to cancel the model loading. This is useful if you wish to add a functionality
     * to cancel the model loading.
     *
     * Example usage:
     *
     * ```typescript
     * const ac = new AbortController();
     * const model = await client.llm.load({
     *   model: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF",
     *   signal: ac.signal,
     * });
     *
     * // Later, to cancel the model loading
     * ac.abort();
     * ```
     *
     * AbortController/AbortSignal is the standard method for cancelling an asynchronous operation in
     * JavaScript. For more information, visit
     * https://developer.mozilla.org/en-US/docs/Web/API/AbortController
     */
    signal?: AbortSignal;
    /**
     * Controls the logging of model loading progress.
     *
     * - If set to `true`, logs progress at the "info" level.
     * - If set to `false`, no logs are emitted. This is the default.
     * - If a specific logging level is desired, it can be provided as a string. Acceptable values are
     *   "debug", "info", "warn", and "error".
     *
     * Logs are directed to the logger specified during the `LMStudioClient` construction.
     *
     * Progress logs will be disabled if an `onProgress` callback is provided.
     *
     * Default value is "info", which logs progress at the "info" level.
     */
    verbose?: boolean | LogLevel;
    /**
     * A function that is called with the progress of the model loading. The function is called with a
     * number between 0 and 1, inclusive, representing the progress of the model loading.
     *
     * If an `onProgress` callback is provided, verbose progress logs will be disabled.
     */
    onProgress?: (progress: number) => void;
}

/**
 * Represents a chat history.
 *
 * @public
 */
export declare class ChatHistory extends MaybeMutable<ChatHistoryData> {
    protected getClassName(): string;
    protected create(data: ChatHistoryData, mutable: boolean): this;
    protected cloneData(data: ChatHistoryData): ChatHistoryData;
    /**
     * Don't use this constructor directly.
     *
     * - To create an empty chat history, use `ChatHistory.createEmpty()`.
     * - To create a chat history with existing data, use `ChatHistory.from()`.
     */
    protected constructor(data: ChatHistoryData, mutable: boolean);
    /**
     * Creates an empty mutable chat history.
     */
    static createEmpty(): ChatHistory;
    /**
     * Quickly create a mutable chat history with something that can be converted to a chat history.
     *
     * The created chat history will be a mutable copy of the input.
     *
     * @example
     * ```ts
     * const history = ChatHistory.from([
     *   { role: "user", content: "Hello" },
     *   { role: "assistant", content: "Hi!" },
     *   { role: "user", content: "What is your name?" },
     * ]);
     * ```
     */
    static from(initializer: ChatHistoryLike): ChatHistory;
    /**
     * Append a text message to the history.
     */
    append(role: ChatMessageRoleData, content: string): void;
    /**
     * Append a message to the history.
     */
    append(message: ChatMessage): void;
    /**
     * Make a copy of this history and append a text message to the copy. Return the copy.
     */
    withAppended(role: ChatMessageRoleData, content: string): ChatHistory;
    /**
     * Make a copy of this history and append a message to the copy. Return the copy.
     */
    withAppended(message: ChatMessage): ChatHistory;
    /**
     * Get the number of messages in the history.
     */
    getLength(): number;
    /**
     * Get the number of messages in the history.
     */
    get length(): number;
    /**
     * Remove the last message from the history. If the history is empty, this method will throw.
     */
    pop(): ChatMessage;
    /**
     * Gets all files contained in this history.
     *
     * @param client - LMStudio client
     */
    getAllFiles(client: LMStudioClient): Array<FileHandle>;
    /**
     * Allows iterating over the files in the history.
     */
    files(client: LMStudioClient): Generator<FileHandle>;
    /**
     * Returns true if this history contains any files.
     */
    hasFiles(): boolean;
    /**
     * Gets the message at the given index. If the index is negative, it will be counted from the end.
     *
     * If the index is out of bounds, this method will throw as oppose to returning undefined. This is
     * to help catch bugs early.
     */
    at(index: number): ChatMessage;
    /**
     * Allows iterating over the messages in the history.
     */
    [Symbol.iterator](): Generator<ChatMessage>;
    /**
     * Given a predicate, the predicate is called for each file in the history.
     *
     * - If the predicate returns true, the file is removed from the history and is collected into the
     *   returned array.
     * - If the predicate returns false, the file is kept in the history.
     *
     * This method is useful if you are implementing a preprocessor that needs to convert certain
     * types of files.
     *
     * If the predicate needs to be async, use the {@link ChatHistory#consumeFilesAsync} method.
     *
     * @param client - LMStudio client
     * @param predicate - The predicate to call for each file.
     * @returns The files that were consumed.
     */
    consumeFiles(client: LMStudioClient, predicate: (file: FileHandle) => boolean): FileHandle[];
    /**
     * Given an async predicate, the predicate is called for each file in the history.
     *
     * - If the predicate returns true, the file is removed from the history and is collected into the
     *  returned array.
     * - If the predicate returns false, the file is kept in the history.
     *
     * This method is useful if you are implementing a preprocessor that needs to convert certain
     * types of files.
     *
     * If you need a synchronous version, use the {@link ChatHistory#consumeFiles} method.
     *
     * @param client - LMStudio client
     * @param predicate - The predicate to call for each file.
     * @returns The files that were consumed.
     */
    consumeFilesAsync(client: LMStudioClient, predicate: (file: FileHandle) => Promise<boolean>): Promise<FileHandle[]>;
    getSystemPrompt(): string;
    replaceSystemPrompt(content: string): void;
    filterInPlace(predicate: (message: ChatMessage) => boolean): void;
    toString(): string;
}

/**
 * @public
 */
export declare interface ChatHistoryData {
    messages: Array<ChatMessageData>;
}

/**
 * Represents anything that can be converted to a ChatHistory.
 *
 * @public
 */
export declare type ChatHistoryLike = ChatHistory | ChatHistoryData | LLMConversationContextInput;

/**
 * Represents a single message in the history.
 *
 * @public
 */
export declare class ChatMessage extends MaybeMutable<ChatMessageData> {
    protected getClassName(): string;
    protected create(data: ChatMessageData, mutable: boolean): this;
    protected cloneData(data: ChatMessageData): ChatMessageData;
    protected constructor(data: ChatMessageData, mutable: boolean);
    /**
     * Create a mutable text only message.
     */
    static create(role: ChatMessageRoleData, content: string): ChatMessage;
    getRole(): "assistant" | "user" | "system" | "tool";
    setRole(role: ChatMessageRoleData): void;
    private getFileParts;
    /**
     * Gets all text contained in this message.
     */
    getText(): string;
    /**
     * Gets all files contained in this message.
     *
     * @param client - LMStudio client
     */
    getFiles(client: LMStudioClient): FileHandle[];
    /**
     * Allows iterating over the files in the message.
     */
    files(client: LMStudioClient): Generator<FileHandle>;
    /**
     * Given a predicate, the predicate is called for each file in the message.
     *
     * - If the predicate returns true, the file is removed from the message and is collected into the
     *   returned array.
     * - If the predicate returns false, the file is kept in the message.
     *
     * This method is useful if you are implementing a preprocessor that needs to convert certain
     * types of files.
     *
     * If the predicate needs to be async, use the {@link ChatMessage#consumeFilesAsync} method.
     *
     * @param client - LMStudio client
     * @param predicate - The predicate to call for each file.
     * @returns The files that were consumed.
     */
    consumeFiles(client: LMStudioClient, predicate: (file: FileHandle) => boolean): FileHandle[];
    /**
     * Given an async predicate, the predicate is called for each file in the message.
     *
     * - If the predicate returns true, the file is removed from the message and is collected into the
     *  returned array.
     * - If the predicate returns false, the file is kept in the message.
     *
     * This method is useful if you are implementing a preprocessor that needs to convert certain
     * types of files.
     *
     * If you need a synchronous version, use the {@link ChatMessage#consumeFiles} method.
     *
     * @param client - LMStudio client
     * @param predicate - The predicate to call for each file.
     * @returns The files that were consumed.
     */
    consumeFilesAsync(client: LMStudioClient, predicate: (file: FileHandle) => Promise<boolean>): Promise<FileHandle[]>;
    /**
     * Returns true if this message contains any files.
     */
    hasFiles(): boolean;
    /**
     * Append text to the message.
     */
    appendText(text: string): void;
    /**
     * Replaces all text in the messages.
     *
     * If the message contains other components (such as files), they will kept. The replaced text
     * will be inserted to the beginning of the message.
     */
    replaceText(text: string): void;
    isSystemPrompt(): boolean;
    isUserMessage(): boolean;
    isAssistantMessage(): boolean;
    toString(): string;
}

/**
 * @public
 */
export declare type ChatMessageData = {
    role: "assistant";
    content: Array<ChatMessagePartTextData | ChatMessagePartFileData | ChatMessagePartToolCallRequestData>;
} | {
    role: "user";
    content: Array<ChatMessagePartTextData | ChatMessagePartFileData>;
} | {
    role: "system";
    content: Array<ChatMessagePartTextData | ChatMessagePartFileData>;
} | {
    role: "tool";
    content: Array<ChatMessagePartToolCallResultData>;
};

/**
 * @public
 */
export declare type ChatMessagePartData = ChatMessagePartTextData | ChatMessagePartFileData | ChatMessagePartToolCallRequestData | ChatMessagePartToolCallResultData;

/**
 * @public
 */
export declare interface ChatMessagePartFileData {
    type: "file";
    /**
     * Original file name that is uploaded.
     */
    name: string;
    /**
     * Internal identifier for the file. Autogenerated, and is unique.
     */
    identifier: string;
    /**
     * Size of the file in bytes.
     */
    sizeBytes: number;
    /**
     * Type of the file.
     */
    fileType: FileType;
}

/**
 * @public
 */
export declare interface ChatMessagePartSubPartFunctionCallRequestData {
    arguments?: Record<string, any>;
    name: string;
}

/**
 * @public
 */
export declare interface ChatMessagePartSubPartToolCallRequest {
    id?: string;
    type: "function";
    function: ChatMessagePartSubPartFunctionCallRequestData;
}

/**
 * @public
 */
export declare interface ChatMessagePartTextData {
    type: "text";
    text: string;
}

/**
 * @public
 */
export declare interface ChatMessagePartToolCallRequestData {
    type: "toolCallRequest";
    /**
     * Tool calls requested
     */
    toolCallRequests: ChatMessagePartSubPartToolCallRequest[];
}

/**
 * @public
 */
export declare interface ChatMessagePartToolCallResultData {
    type: "toolCallResult";
    /**
     * Result of a tool call
     */
    content: string;
    /**
     * The tool call ID that this result is for
     */
    toolCallId?: string;
}

/**
 * @public
 */
export declare type ChatMessageRoleData = "assistant" | "user" | "system" | "tool";

/**
 * Represents a source of a citation.
 *
 * @public
 */
export declare interface CitationSource {
    fileName: string;
    absoluteFilePath?: string;
    pageNumber?: number | [start: number, end: number];
    lineNumber?: number | [start: number, end: number];
}

/**
 * Theme color options
 *
 * @public
 */
export declare type ColorPalette = "red" | "green" | "blue" | "yellow" | "orange" | "purple" | "default";

/**
 * @public
 */
export declare interface ConfigSchematics<TVirtualConfigSchematics extends VirtualConfigSchematics> {
    [configSchematicsBrand]?: TVirtualConfigSchematics;
}

declare const configSchematicsBrand: unique symbol;

/**
 * The opaque type for KVConfigSchematicsBuilder that is exposed in lmstudio.js SDK. Notably, this
 * has significantly simplified types and is easier to use.
 *
 * @public
 */
export declare interface ConfigSchematicsBuilder<TVirtualConfigSchematics extends VirtualConfigSchematics> {
    [configSchematicsBuilderBrand]?: TVirtualConfigSchematics;
    /**
     * Adds a field to the config schematics.
     */
    field<TKey extends string, TValueTypeKey extends keyof GlobalKVFieldValueTypeLibraryMap & string>(key: TKey, valueTypeKey: TValueTypeKey, valueTypeParams: GlobalKVFieldValueTypeLibraryMap[TValueTypeKey]["param"], defaultValue: GlobalKVFieldValueTypeLibraryMap[TValueTypeKey]["value"]): ConfigSchematicsBuilder<TVirtualConfigSchematics & {
        [key in TKey]: {
            key: TKey;
            type: GlobalKVFieldValueTypeLibraryMap[TValueTypeKey]["value"];
            valueTypeKey: TValueTypeKey;
        };
    }>;
    /**
     * Adds a "scope" to the config schematics. This is useful for grouping fields together.
     */
    scope<TScopeKey extends string, TInnerVirtualConfigSchematics extends VirtualConfigSchematics>(scopeKey: TScopeKey, fn: (builder: ConfigSchematicsBuilder<{}>) => ConfigSchematicsBuilder<TInnerVirtualConfigSchematics>): ConfigSchematicsBuilder<TVirtualConfigSchematics & {
        [InnerKey in keyof TInnerVirtualConfigSchematics & string as `${TScopeKey}.${InnerKey}`]: TInnerVirtualConfigSchematics[InnerKey];
    }>;
    build(): ConfigSchematics<TVirtualConfigSchematics>;
}

declare const configSchematicsBuilderBrand: unique symbol;

/**
 * @public
 */
declare interface CreateCitationBlockOpts {
    fileName: string;
    fileIdentifier: string;
    pageNumber?: number | [start: number, end: number];
    lineNumber?: number | [start: number, end: number];
}

/**
 * @public
 */
export declare function createConfigSchematics(): ConfigSchematicsBuilder<{}>;

/**
 * @public
 */
export declare interface CreateContentBlockOpts {
    includeInContext?: boolean;
    label?: string;
    labelColor?: ColorPalette;
}

/**
 * @public
 */
export declare type DiagnosticsLogEvent = {
    timestamp: number;
    data: DiagnosticsLogEventData;
};

/**
 * @public
 */
export declare type DiagnosticsLogEventData = {
    type: "llm.prediction.input";
    modelPath: string;
    modelIdentifier: string;
    input: string;
};

/** @public */
export declare class DiagnosticsNamespace {
    private readonly diagnosticsPort;
    private readonly validator;
    /**
     * Register a callback to receive log events. Return a function to stop receiving log events.
     *
     * This method is in alpha. Do not use this method in production yet.
     * @alpha
     */
    unstable_streamLogs(listener: (logEvent: DiagnosticsLogEvent) => void): () => void;
}

/** @public */
declare interface DownloadArtifactOpts {
    owner: string;
    name: string;
    revisionNumber: number;
    /**
     * Where to save the artifact.
     */
    path: string;
    onProgress?: (update: DownloadProgressUpdate) => void;
    onStartFinalizing?: () => void;
    signal?: AbortSignal;
}

/**
 * Represents a model that exists locally and can be loaded.
 *
 * @public
 */
export declare type DownloadedModel = {
    /**
     * The type of the model.
     */
    type: "llm" | "embedding";
    /**
     * The path of the model. Use to load the model.
     */
    path: string;
    /**
     * The size of the model in bytes.
     */
    sizeBytes: number;
    /**
     * The architecture of the model.
     */
    architecture?: string;
};

/** @public */
export declare interface DownloadOpts {
    onProgress?: (update: DownloadProgressUpdate) => void;
    onStartFinalizing?: () => void;
    signal?: AbortSignal;
}

/**
 * @public
 */
export declare interface DownloadProgressUpdate {
    downloadedBytes: number;
    totalBytes: number;
    speedBytesPerSecond: number;
}

/**
 * This represents a set of requirements for a model. It is not tied to a specific model, but rather
 * to a set of requirements that a model must satisfy.
 *
 * For example, if you got the model via `client.llm.get("my-identifier")`, you will get a
 * `LLMModel` for the model with the identifier `my-identifier`. If the model is unloaded, and
 * another model is loaded with the same identifier, using the same `LLMModel` will use the new
 * model.
 *
 * @public
 */
export declare abstract class DynamicHandle {
    /**
     * Gets the information of the model that is currently associated with this `LLMModel`. If no
     * model is currently associated, this will return `undefined`.
     *
     * Note: As models are loaded/unloaded, the model associated with this `LLMModel` may change at
     * any moment.
     */
    getModelInfo(): Promise<ModelDescriptor | undefined>;
    protected getLoadConfig(stack: string): Promise<KVConfig>;
}

/**
 * This represents a set of requirements for a model. It is not tied to a specific model, but rather
 * to a set of requirements that a model must satisfy.
 *
 * For example, if you got the model via `client.embedding.get("my-identifier")`, you will get a
 * `EmbeddingModel` for the model with the identifier `my-identifier`. If the model is unloaded, and
 * another model is loaded with the same identifier, using the same `EmbeddingModel` will use the
 * new model.
 *
 * @public
 */
export declare class EmbeddingDynamicHandle extends DynamicHandle {
    embedString(inputString: string): Promise<{
        embedding: number[];
    }>;
    getContextLength(): Promise<number>;
    getEvalBatchSize(): Promise<number>;
    tokenize(inputString: string): Promise<number[]>;
}

/**
 * @public
 */
export declare interface EmbeddingLoadModelConfig {
    gpuOffload?: LLMLlamaAccelerationSetting;
    contextLength?: number;
    ropeFrequencyBase?: number;
    ropeFrequencyScale?: number;
    keepModelInMemory?: boolean;
    tryMmap?: boolean;
}

/** @public */
export declare class EmbeddingNamespace extends ModelNamespace<EmbeddingLoadModelConfig, EmbeddingDynamicHandle, EmbeddingSpecificModel> {
}

/**
 * Represents a specific loaded Embedding. Most Embedding related operations are inherited from
 * {@link EmbeddingDynamicHandle}.
 *
 * @public
 */
export declare class EmbeddingSpecificModel extends EmbeddingDynamicHandle implements SpecificModel {
    readonly identifier: string;
    readonly path: string;
}

declare interface EnsureAuthenticatedOpts {
    onAuthenticationUrl: (url: string) => void;
}

/**
 * Represents a file. Currently, the file can be either in the local file system or base64 encoded.
 *
 * @public
 */
export declare class FileHandle {
    readonly filesNamespace: FilesNamespace;
    readonly identifier: string;
    readonly type: FileType;
    readonly sizeBytes: number;
    /**
     * Original file name
     */
    readonly name: string;
    private readonly parsedIdentifier;
    /**
     * Gets the absolute file path of this file.
     */
    getFilePath(): Promise<string>;
    isImage(): boolean;
}

/**
 * @public
 *
 * The namespace for file-related operations.
 */
export declare class FilesNamespace {
    private readonly validator;
    /**
     * Uploads a file with the given name and content. The file uploaded will be temporary and will be
     * deleted when the client disconnects.
     */
    uploadTempFile(fileName: string, content: Uint8Array): Promise<FileHandle>;
}

/**
 * @public
 *
 * TODO: Documentation
 */
export declare type FileType = "image" | "text/plain" | "application/pdf" | "application/word" | "text/other" | "unknown";

/**
 * TODO: Documentation
 *
 * @public
 */
declare type Generator_2 = (ctl: GeneratorController) => Promise<void>;
export { Generator_2 as Generator }

/**
 * @public
 */
export declare type GeneratorController = Omit<ProcessingController, never>;

/**
 * @public
 */
export declare type GlobalKVFieldValueTypeLibraryMap = GlobalKVValueTypesLibrary extends KVFieldValueTypeLibrary<infer TKVFieldValueTypeLibraryMap> ? TKVFieldValueTypeLibraryMap : never;

/**
 * @public
 */
export declare type GlobalKVValueTypesLibrary = typeof kvValueTypesLibrary;

/**
 * Stringify options passed to actual implementations of stringify.
 *
 * @public
 */
export declare interface InnerFieldStringifyOpts {
    /**
     * Translate function.
     */
    t: (key: string, fallback: string) => string;
    /**
     * If exists, a soft cap on how long the stringified value should be.
     *
     * This does not have to be followed. Mostly used for fields like promptFormatTemplate where it
     * can grow very large.
     */
    desiredLength?: number;
}

/**
 * Represents a single field value type definition.
 *
 * @public
 */
export declare interface KVConcreteFieldValueType {
    paramType: ZodSchema;
    schemaMaker: (param: any) => ZodSchema;
    effectiveEquals: (a: any, b: any, typeParam: any) => boolean;
    stringify: (value: any, typeParam: any, opts: InnerFieldStringifyOpts) => string;
}

/**
 * @public
 */
export declare type KVConcreteFieldValueTypesMap = Map<string, KVConcreteFieldValueType>;

/**
 * TODO: Documentation
 *
 * @public
 */
export declare interface KVConfig {
    fields: Array<KVConfigField>;
}

/**
 * TODO: Documentation
 *
 * @public
 */
export declare interface KVConfigField {
    key: string;
    value?: any;
}

/**
 * Represents a library of field value types.
 *
 * @public
 */
export declare class KVFieldValueTypeLibrary<TKVFieldValueTypeLibraryMap extends KVVirtualFieldValueTypesMapping> {
    private readonly valueTypes;
    constructor(valueTypes: KVConcreteFieldValueTypesMap);
    /**
     * Gets the schema for a specific field value type with the given key and parameters.
     */
    getSchema<TKey extends keyof TKVFieldValueTypeLibraryMap & string>(key: TKey, param: TKVFieldValueTypeLibraryMap[TKey]["param"]): ZodSchema<TKVFieldValueTypeLibraryMap[TKey]["value"]>;
    parseParamTypes<TKey extends keyof TKVFieldValueTypeLibraryMap & string>(key: TKey, param: any): TKVFieldValueTypeLibraryMap[TKey]["param"];
    effectiveEquals<TKey extends keyof TKVFieldValueTypeLibraryMap & string>(key: TKey, typeParam: TKVFieldValueTypeLibraryMap[TKey]["param"], a: TKVFieldValueTypeLibraryMap[TKey]["value"], b: TKVFieldValueTypeLibraryMap[TKey]["value"]): boolean;
    stringify<TKey extends keyof TKVFieldValueTypeLibraryMap & string>(key: TKey, typeParam: TKVFieldValueTypeLibraryMap[TKey]["param"], opts: InnerFieldStringifyOpts, value: TKVFieldValueTypeLibraryMap[TKey]["value"]): string;
}

/**
 * @public
 */
export declare const kvValueTypesLibrary: KVFieldValueTypeLibrary<{
    numeric: {
        value: number;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            min?: number | undefined;
            max?: number | undefined;
            step?: number | undefined;
            int?: boolean | undefined;
            precision?: number | undefined;
            slider?: {
                min: number;
                max: number;
                step: number;
            } | undefined;
            shortHand?: string | undefined;
        };
    };
} & {
    checkboxNumeric: {
        value: {
            value: number;
            checked: boolean;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            min?: number | undefined;
            max?: number | undefined;
            step?: number | undefined;
            int?: boolean | undefined;
            precision?: number | undefined;
            slider?: {
                min: number;
                max: number;
                step: number;
            } | undefined;
            uncheckedHint?: string | undefined;
        };
    };
} & {
    string: {
        value: string;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            minLength?: number | undefined;
            maxLength?: number | undefined;
            isParagraph?: boolean | undefined;
            isProtected?: boolean | undefined;
            placeholder?: string | undefined;
        };
    };
} & {
    select: {
        value: string;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            options: (string | {
                value: string;
                displayName: string;
            })[];
        };
    };
} & {
    boolean: {
        value: boolean;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    stringArray: {
        value: string[];
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            maxNumItems?: number | undefined;
            allowEmptyStrings?: boolean | undefined;
        };
    };
} & {
    contextOverflowPolicy: {
        value: "stopAtLimit" | "truncateMiddle" | "rollingWindow";
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    context: {
        value: ({
            type: "jsonFile";
            absPath: string;
        } | {
            type: "yamlFile";
            absPath: string;
        })[];
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    contextLength: {
        value: number;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            max?: number | undefined;
        };
    };
} & {
    modelIdentifier: {
        value: string;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            domain?: ("llm" | "embedding" | "imageGen" | "transcription" | "tts")[] | undefined;
        };
    };
} & {
    llmPromptTemplate: {
        value: {
            type: "manual" | "jinja";
            stopStrings: string[];
            manualPromptTemplate?: {
                beforeSystem: string;
                afterSystem: string;
                beforeUser: string;
                afterUser: string;
                beforeAssistant: string;
                afterAssistant: string;
            } | undefined;
            jinjaPromptTemplate?: {
                template: string;
                bosToken: string;
                eosToken: string;
                inputFormat?: "promptOnly" | "promptWithImages" | "promptWithImagesNewline" | "promptWithNumberedImages1" | "promptWithNumberedImages2" | "messageListWithImageType1" | "messageListWithImageType2" | "llamaCustomTools" | "mistralTools" | "qwenTools" | undefined;
            } | undefined;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    llamaStructuredOutput: {
        value: {
            type: "none";
        } | {
            type: "json";
            jsonSchema?: any;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    toolUse: {
        value: {
            type: "none";
        } | {
            type: "toolArray";
            tools?: {
                function: {
                    name: string;
                    description?: string | undefined;
                    parameters?: {
                        type: "object";
                        properties: Record<string, any>;
                        required?: string[] | undefined;
                        additionalProperties?: boolean | undefined;
                    } | undefined;
                };
                type: "function";
            }[] | undefined;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    llamaAccelerationOffloadRatio: {
        value: number | "max" | "off";
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
            numLayers?: number | undefined;
        };
    };
} & {
    llamaAccelerationMainGpu: {
        value: number;
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    llamaAccelerationTensorSplit: {
        value: number[];
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    llamaMirostatSampling: {
        value: {
            version: 0 | 2 | 1;
            learningRate: number;
            targetEntropy: number;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    llamaLogitBias: {
        value: [number, number | "-inf"][];
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
} & {
    retrievalChunkingMethod: {
        value: {
            type: "recursive-v1";
            chunkSize: number;
            chunkOverlap: number;
        };
        param: {
            displayName?: string | undefined;
            hint?: string | undefined;
            modelCentric?: boolean | undefined;
            nonConfigurable?: boolean | undefined;
            machineDependent?: boolean | undefined;
            warning?: string | undefined;
            isExperimental?: boolean | undefined;
        };
    };
}>;

/**
 * Used internally by KVFieldValueTypesLibrary to keep track of a single field value type definition
 * with the generics.
 *
 * @public
 */
export declare interface KVVirtualFieldValueType {
    value: any;
    param: any;
}

/**
 * Used internally by KVFieldValueTypesLibrary to keep track of all field value type definitions
 * with the generics.
 *
 * @public
 */
export declare type KVVirtualFieldValueTypesMapping = {
    [key: string]: KVVirtualFieldValueType;
};

/**
 * Options for applying a prompt template.
 * @public
 */
export declare interface LLMApplyPromptTemplateOpts {
    /**
     * Whether to omit the BOS token when formatting.
     *
     * Default: false
     */
    omitBosToken?: boolean;
    /**
     * Whether to omit the EOS token when formatting.
     *
     * Default: false
     */
    omitEosToken?: boolean;
}

/**
 * Represents the history of a conversation, which is represented as an array of messages.
 *
 * @public
 */
export declare type LLMChatHistory = Array<LLMChatHistoryMessage>;

/**
 * Represents a single message in the history.
 *
 * @public
 */
export declare interface LLMChatHistoryMessage {
    role: LLMChatHistoryRole;
    content: LLMChatHistoryMessageContent;
}

/**
 * Represents the content of a message in the history.
 * @public
 */
export declare type LLMChatHistoryMessageContent = Array<LLMChatHistoryMessageContentPart>;

/**
 * Represents a part of the content of a message in the history.
 *
 * @public
 */
export declare type LLMChatHistoryMessageContentPart = {
    type: "text";
    text: string;
} | {
    type: "imageBase64";
    base64: string;
};

/**
 * Represents a role in a specific message in the history. This is a string enum, and can only be
 * one of the following values:
 *
 * - `system`: Usually used for system prompts
 * - `user`: Used for user inputs / queries
 * - `assistant`: Used for assistant responses, usually generated AI, but can also be fed by a human
 *
 * @public
 */
export declare type LLMChatHistoryRole = string;

/**
 * Represents the input context for a completion request. This is a string that represents the
 * entire conversation history.
 *
 * @public
 */
export declare type LLMCompletionContextInput = string;

/**
 * Represents a raw context object that can be fed into the model.
 *
 * @public
 */
export declare interface LLMContext {
    history: LLMChatHistory;
}

/**
 * Behavior for when the generated tokens length exceeds the context window size. Only the following
 * values are allowed:
 *
 * - `stopAtLimit`: Stop the prediction when the generated tokens length exceeds the context window
 *   size. If the generation is stopped because of this limit, the `stopReason` in the prediction
 *   stats will be set to `contextLengthReached`.
 * - `truncateMiddle`: Keep the system prompt and the first user message, truncate middle.
 * - `rollingWindow`: Maintain a rolling window and truncate past messages.
 *
 * @public
 */
export declare type LLMContextOverflowPolicy = "stopAtLimit" | "truncateMiddle" | "rollingWindow";

/**
 * Represents the input context for a conversation request. This is an array of objects, where each
 * object represents a single message in the conversation.
 *
 * @deprecated Usage of this type is deprecated. Will soon be replaced with a superset of this type.
 *
 * @public
 */
export declare type LLMConversationContextInput = Array<{
    role: LLMChatHistoryRole;
    content: string;
}>;

/**
 * This represents a set of requirements for a model. It is not tied to a specific model, but rather
 * to a set of requirements that a model must satisfy.
 *
 * For example, if you got the model via `client.llm.get("my-identifier")`, you will get a
 * `LLMModel` for the model with the identifier `my-identifier`. If the model is unloaded, and
 * another model is loaded with the same identifier, using the same `LLMModel` will use the new
 * model.
 *
 * @public
 */
export declare class LLMDynamicHandle extends DynamicHandle {
    /**
     * Use the loaded model to predict text.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const result = await model.complete("When will The Winds of Winter be released?");
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * model.complete("When will The Winds of Winter be released?")
     *  .then(result =\> console.log(result.content))
     *  .catch(error =\> console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * for await (const { content } of model.complete("When will The Winds of Winter be released?")) {
     *   process.stdout.write(content);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const { content } of prediction) {
     *   process.stdout.write(content);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param prompt - The prompt to use for prediction.
     * @param opts - Options for the prediction.
     */
    complete(prompt: LLMCompletionContextInput, opts?: LLMPredictionOpts): OngoingPrediction;
    private resolveCompletionContext;
    /**
     * Use the loaded model to generate a response based on the given history.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const history = [{ role: 'user', content: "When will The Winds of Winter be released?" }];
     * const result = await model.respond(history);
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * const history = [{ role: 'user', content: "When will The Winds of Winter be released?" }];
     * model.respond(history)
     *  .then(result => console.log(result.content))
     *  .catch(error => console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * const history = [{ role: 'user', content: "When will The Winds of Winter be released?" }];
     * for await (const { content } of model.respond(history)) {
     *   process.stdout.write(content);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const history = [{ role: 'user', content: "When will The Winds of Winter be released?" }];
     * const prediction = model.respond(history);
     * for await (const { content } of prediction) {
     *   process.stdout.write(content);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param history - The LLMChatHistory array to use for generating a response.
     * @param opts - Options for the prediction.
     */
    respond(history: ChatHistoryLike, opts?: LLMPredictionOpts): OngoingPrediction;
    getContextLength(): Promise<number>;
    applyPromptTemplate(history: ChatHistoryLike, opts?: LLMApplyPromptTemplateOpts): Promise<string>;
    tokenize(inputString: string): Promise<number[]>;
    countTokens(inputString: string): Promise<number>;
}

/**
 * @public
 */
export declare interface LLMGenInfo {
    indexedModelIdentifier: string;
    identifier: string;
    loadModelConfig: KVConfig;
    predictionConfig: KVConfig;
    stats: LLMPredictionStats;
}

/**
 * This type contains a unique literal for each known input format for Jinja template rendering.
 * ChatHistoryData will be converted to this format before being passed to the Jinja template.
 *
 * See below for examples of each format.
 *
 * ### promptOnly
 * Prompt in `content` field, no mention of images
 * ```typescript
 * { "messages": [{ role: "user", content: "What is this?" }] }
 * ```
 *
 * ### promptWithImages
 * Prompt in 'content' field, with 1-n images embedded at the start as `<image>` strings
 * ```typescript
 * { "messages": [{ role: "user", content: "<image>What is this?"}] }
 * ```
 *
 * ### promptWithImagesNewline
 * Prompt in 'content' field, with 1-n images embedded at the start as `<image>\n` strings
 * ```typescript
 * { "messages": [{ role: "user", content: "<image>\nWhat is this?"}] }
 * ```
 *
 * ### promptWithNumberedImages1
 * Prompt in 'content' field, with 1-n numbered images embedded at the start as `<image_*>` strings
 * ```typescript
 * { "messages": [{ role: "user", content: "<image_1><image_2>What is this?"}] }
 * ```
 *
 * ### promptWithNumberedImages2
 * Prompt in 'content' field, with 1-n numbered images embedded at the start as `[img-*]` strings
 * ```typescript
 * { "messages": [{ role: "user", content: "[img-1][img-2]What is this?"}] }
 * ```
 *
 * ### messageListWithImageType1
 * 'content' field contains a list of message parts, where each part is of type "image" or "text".
 * "text" parts contain text in the `text` field.
 * ```typescript
 * {
 *   "messages": [{
 *     role: "user",
 *     content: [{ type: "image" }{ type: "text", text: "What is this?"}]
 *   }]
 * }
 * ```
 *
 * ### messageListWithImageType2
 * 'content' field contains a list of message parts, where each part is of type "image" or "text".
 * "text" parts contain text in the `content` field.
 * ```typescript
 * {
 *   "messages": [{
 *     role: "user",
 *     content: [{ type: "image" }{ type: "text", content: "What is this?"}]
 *   }]
 * }
 * ```
 *
 * ### llamaCustomTools
 * Llama tool-use format. No images. The "assistant" can make requests to tool calls. The "tool"
 * role contains the results of the tool calls. The "custom_tools" field is used to define the tools
 * that the model can request.
 * ```typescript
 * {
 *   messages: [
 *     { role: "user", content: "What's the delivery date for order 123" },
 *     { role: "assistant", content: "Let me check your delivery date.",
 *       tool_calls: [{
 *         type: "function",
 *         function: { name: "get_delivery_date", arguments: "{\"order_id\":\"123\"}" }
 *       }]
 *     },
 *     { role: "tool", content: '{"order_id": "123", "delivery_date": "March 1st, 2024"}' }
 *   ],
 *   custom_tools: [{
 *     type: "function",
 *     function: {
 *       name: "get_delivery_date",
 *       description: "Get the delivery date for a customer's order",
 *       parameters: {
 *         type: "object",
 *         properties: {
 *           order_id: {
 *             type: "string",
 *             description: "The customer's order ID."
 *           }
 *         },
 *         required: ["order_id"],
 *         additionalProperties: false
 *       }
 *     }
 *   }]
 * }
 * ```
 *
 * ### mistralTools
 * Mistral tool-use format. Similar to llamaCustomTools but with additional validation rules, and
 * tools are passed through the "tools" field instead of the "custom_tools" field.
 * IDs must be present in both "tool_calls" from "assistant" and in "tool_call_id" when a message
 * is sent from the "tool" role. IDs must be 9 alphanumeric characters long.
 * ```typescript
 * {
 *   messages: [
 *     { role: "user", content: "What's the delivery date for order 123?" },
 *     { role: "assistant", tool_calls: [{
 *         id: "123456789",
 *         function: {
 *           name: "get_delivery_date",
 *           arguments: "{\"order_id\":\"123\"}"
 *         }
 *     }]},
 *     { role: "tool",
 *       tool_call_id: "123456789",
 *       content: '{"order_id": "123", "delivery_date": "March 1st, 2024"}'
 *     }
 *   ],
 *   tools: [<tool jsons here>]
 * }
 * ```
 *
 * ### qwenTools
 * The same as `llamaCustomTools`, but the "tools" field is used to define the tools
 * that the model can request (instead of "custom_tools" for `llamaCustomTools`).
 * ```typescript
 * {
 *   messages: [
 *     { role: "user", content: "What's the delivery date for order 123" },
 *     { role: "assistant", content: "Let me check your delivery date.",
 *       tool_calls: [{
 *         type: "function",
 *         function: { name: "get_delivery_date", arguments: "{\"order_id\":\"123\"}" }
 *       }]
 *     },
 *     { role: "tool", content: '{"order_id": "123", "delivery_date": "March 1st, 2024"}' }
 *   ],
 *   tools: [<tool jsons here>]
 * }
 * ```
 *
 * @public
 */
export declare type LLMJinjaInputFormat = "promptOnly" | "promptWithImages" | "promptWithImagesNewline" | "promptWithNumberedImages1" | "promptWithNumberedImages2" | "messageListWithImageType1" | "messageListWithImageType2" | "llamaCustomTools" | "mistralTools" | "qwenTools";

/**
 * @public
 */
export declare interface LLMJinjaPromptTemplate {
    template: string;
    /**
     * Required for applying Jinja template.
     */
    bosToken: string;
    /**
     * Required for applying Jinja template.
     */
    eosToken: string;
    /**
     * Format of the input to the Jinja template.
     */
    inputFormat?: LLMJinjaInputFormat;
}

/**
 * How much of the model's work should be offloaded to the GPU. The value should be between 0 and 1.
 * A value of 0 means that no layers are offloaded to the GPU, while a value of 1 means that all
 * layers (that can be offloaded) are offloaded to the GPU.
 *
 * @public
 */
export declare type LLMLlamaAccelerationOffloadRatio = number | "max" | "off";

/**
 * Settings related to offloading work to the GPU.
 *
 * @public
 */
export declare type LLMLlamaAccelerationSetting = {
    ratio: LLMLlamaAccelerationOffloadRatio;
    mainGpu: number;
    tensorSplit: Array<number>;
};

/** @public */
export declare interface LLMLoadModelConfig {
    /**
     * How much of the model's work should be offloaded to the GPU. The value should be between 0 and 1.
     * A value of 0 means that no layers are offloaded to the GPU, while a value of 1 means that all
     * layers (that can be offloaded) are offloaded to the GPU.
     *
     * Alternatively, the value can be set to "auto", which means it will be determined automatically.
     * (Currently uses the value in the preset.)
     *
     * @public
     */
    gpuOffload?: LLMLlamaAccelerationSetting;
    /**
     * The size of the context length in number of tokens. This will include both the prompts and the
     * responses. Once the context length is exceeded, the value set in
     * {@link LLMPredictionConfigBase#contextOverflowPolicy} is used to determine the behavior.
     *
     * See {@link LLMContextOverflowPolicy} for more information.
     */
    contextLength?: number;
    ropeFrequencyBase?: number;
    ropeFrequencyScale?: number;
    /**
     * Prompt evaluation batch size.
     */
    evalBatchSize?: number;
    flashAttention?: boolean;
    keepModelInMemory?: boolean;
    seed?: number;
    useFp16ForKVCache?: boolean;
    tryMmap?: boolean;
    numExperts?: number;
}

/**
 * @public
 */
export declare interface LLMManualPromptTemplate {
    /**
     * String to be prepended to the system prompt.
     */
    beforeSystem: string;
    /**
     * String to be appended to the system prompt.
     */
    afterSystem: string;
    /**
     * String to be prepended to a user message.
     */
    beforeUser: string;
    /**
     * String to be appended to a user message.
     */
    afterUser: string;
    /**
     * String to be prepended to an assistant message.
     */
    beforeAssistant: string;
    /**
     * String to be appended to an assistant message.
     */
    afterAssistant: string;
}

/** @public */
export declare class LLMNamespace extends ModelNamespace<LLMLoadModelConfig, LLMDynamicHandle, LLMSpecificModel> {
}

/**
 * Shared config for running predictions on an LLM.
 *
 * @public
 */
export declare interface LLMPredictionConfig {
    /**
     * Number of tokens to predict at most. If set to false, the model will predict as many tokens as it
     * wants.
     *
     * When the prediction is stopped because of this limit, the `stopReason` in the prediction stats
     * will be set to `maxPredictedTokensReached`.
     *
     * See {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    maxPredictedTokens?: number | false;
    /**
     * The temperature parameter for the prediction model. A higher value makes the predictions more
     * random, while a lower value makes the predictions more deterministic. The value should be
     * between 0 and 1.
     */
    temperature?: number;
    /**
     * An array of strings. If the model generates one of these strings, the prediction will stop.
     *
     * When the prediction is stopped because of this limit, the `stopReason` in the prediction stats
     * will be set to `stopStringFound`.
     *
     * See {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    stopStrings?: Array<string>;
    /**
     * An array of strings. If the model generates one of these strings, the prediction will stop with
     * the `stopReason` `toolCalls`.
     *
     * See {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    toolCallStopStrings?: Array<string>;
    /**
     * The behavior for when the generated tokens length exceeds the context window size. The allowed
     * values are:
     *
     * - `stopAtLimit`: Stop the prediction when the generated tokens length exceeds the context
     *   window size. If the generation is stopped because of this limit, the `stopReason` in the
     *   prediction stats will be set to `contextLengthReached`
     * - `truncateMiddle`: Keep the system prompt and the first user message, truncate middle.
     * - `rollingWindow`: Maintain a rolling window and truncate past messages.
     */
    contextOverflowPolicy?: LLMContextOverflowPolicy;
    /**
     * TODO: Documentation
     */
    structured?: LLMStructuredPredictionSetting;
    /**
     * TODO: Documentation
     */
    tools?: LLMToolUseSetting;
    /**
     * TODO: Documentation
     */
    topKSampling?: number;
    /**
     * TODO: Documentation
     */
    repeatPenalty?: number | false;
    /**
     * TODO: Documentation
     */
    minPSampling?: number | false;
    /**
     * TODO: Documentation
     */
    topPSampling?: number | false;
    /**
     * TODO: Documentation
     */
    xtcProbability?: number | false;
    /**
     * TODO: Documentation
     */
    xtcThreshold?: number | false;
    /**
     * TODO: Documentation
     */
    logProbs?: number | false;
    /**
     * TODO: Documentation
     */
    cpuThreads?: number;
    /**
     * This is WIP. Will have an easier to use type in the future.
     *
     * TODO: Documentation
     */
    promptTemplate?: LLMPromptTemplate;
}

declare interface LLMPredictionFragment {
    content: string;
}

/**
 * Shared options for any prediction methods (`.complete`/`.respond`).
 *
 * Note, this interface extends the `LLMPredictionConfig` interface, which contains parameters that
 * you can override for the LLM. See {@link LLMPredictionConfig} for more information.
 *
 * @public
 */
export declare interface LLMPredictionOpts extends LLMPredictionConfig {
    /**
     * A callback that is called when the model is processing the prompt. The callback is called with
     * a number between 0 and 1, representing the progress of the prompt processing.
     *
     * Prompt processing progress callbacks will only be called before the first token is emitted.
     */
    onPromptProcessingProgress?: (progress: number) => void;
    /**
     * A callback that is called when the model has output the first token.
     */
    onFirstToken?: () => void;
}

/** @public */
export declare interface LLMPredictionStats {
    /**
     * The reason why the prediction stopped.
     *
     * This is a string enum with the following possible values:
     *
     * - `userStopped`: The user stopped the prediction. This includes calling the `cancel` method on
     *   the `OngoingPrediction` object.
     * - `modelUnloaded`: The model was unloaded during the prediction.
     * - `failed`: An error occurred during the prediction.
     * - `eosFound`: The model predicted an end-of-sequence token, which is a way for the model to
     *   indicate that it "thinks" the sequence is complete.
     * - `stopStringFound`: A stop string was found in the prediction. (Stop strings can be specified
     *   with the `stopStrings` config option. This stop reason will only occur if the `stopStrings`
     *   config option is set.)
     * - `maxPredictedTokensReached`: The maximum number of tokens to predict was reached. (Length
     *   limit can be specified with the `maxPredictedTokens` config option. This stop reason will
     *   only occur if the `maxPredictedTokens` config option is set to a value other than -1.)
     * - `contextLengthReached`: The context length was reached. This stop reason will only occur if
     *   the `contextOverflowPolicy` is set to `stopAtLimit`.
     */
    stopReason: LLMPredictionStopReason;
    /**
     * The average number of tokens predicted per second.
     *
     * Note: This value can be undefined in the case of a very short prediction which results in a
     * NaN or a Infinity value.
     */
    tokensPerSecond?: number;
    /**
     * The number of GPU layers used in the prediction.
     */
    numGpuLayers?: number;
    /**
     * The time it took to predict the first token in seconds.
     */
    timeToFirstTokenSec?: number;
    /**
     * The number of tokens that were supplied.
     */
    promptTokensCount?: number;
    /**
     * The number of tokens that were predicted.
     */
    predictedTokensCount?: number;
    /**
     * The total number of tokens. This is the sum of the prompt tokens and the predicted tokens.
     */
    totalTokensCount?: number;
}

/**
 * Represents the reason why a prediction stopped. Only the following values are possible:
 *
 * - `userStopped`: The user stopped the prediction. This includes calling the `cancel` method on
 *   the `OngoingPrediction` object.
 * - `modelUnloaded`: The model was unloaded during the prediction.
 * - `failed`: An error occurred during the prediction.
 * - `eosFound`: The model predicted an end-of-sequence token, which is a way for the model to
 *   indicate that it "thinks" the sequence is complete.
 * - `stopStringFound`: A stop string was found in the prediction. (Stop strings can be specified
 *   with the `stopStrings` config option. This stop reason will only occur if the `stopStrings`
 *   config option is set to an array of strings.)
 * - `maxPredictedTokensReached`: The maximum number of tokens to predict was reached. (Length limit
 *   can be specified with the `maxPredictedTokens` config option. This stop reason will only occur
 *   if the `maxPredictedTokens` config option is set to a value other than -1.)
 * - `contextLengthReached`: The context length was reached. This stop reason will only occur if the
 *   `contextOverflowPolicy` is set to `stopAtLimit`.
 *
 * @public
 */
export declare type LLMPredictionStopReason = "userStopped" | "modelUnloaded" | "failed" | "eosFound" | "stopStringFound" | "toolCalls" | "maxPredictedTokensReached" | "contextLengthReached";

/**
 * @public
 */
export declare interface LLMPromptTemplate {
    type: LLMPromptTemplateType;
    manualPromptTemplate?: LLMManualPromptTemplate;
    jinjaPromptTemplate?: LLMJinjaPromptTemplate;
    /**
     * Additional stop strings to be used with this template.
     */
    stopStrings: Array<string>;
}

/** @public */
export declare type LLMPromptTemplateType = "manual" | "jinja";

/**
 * Represents a specific loaded LLM. Most LLM related operations are inherited from
 * {@link LLMDynamicHandle}.
 *
 * @public
 */
export declare class LLMSpecificModel extends LLMDynamicHandle implements SpecificModel {
    readonly identifier: string;
    readonly path: string;
}

/**
 * Settings for structured prediction. Structured prediction is a way to force the model to generate
 * predictions that conform to a specific structure.
 *
 * For example, you can use structured prediction to make the model only generate valid JSON, or
 * event JSON that conforms to a specific schema (i.e. having strict types).
 *
 * Some examples:
 *
 * Only generate valid JSON:
 *
 * ```ts
 * const prediction = model.complete("...", {
 *   maxPredictedTokens: 100,
 *   structured: { type: "json" },
 * });
 * ```
 *
 * Only generate JSON that conforms to a specific schema (See https://json-schema.org/ for more
 * information on authoring JSON schema):
 *
 * ```ts
 * const schema = {
 *   type: "object",
 *   properties: {
 *     name: { type: "string" },
 *     age: { type: "number" },
 *   },
 *   required: ["name", "age"],
 * };
 * const prediction = model.complete("...", {
 *   maxPredictedTokens: 100,
 *   structured: { type: "json", jsonSchema: schema },
 * });
 * ```
 *
 * By default, `{ type: "none" }` is used, which means no structured prediction is used.
 *
 * Caveats:
 *
 * - Although the model is forced to generate predictions that conform to the specified structure,
 *   the prediction may be interrupted (for example, if the user stops the prediction). When that
 *   happens, the partial result may not conform to the specified structure. Thus, always check the
 *   prediction result before using it, for example, by wrapping the `JSON.parse` inside a try-catch
 *   block.
 * - In certain cases, the model may get stuck. For example, when forcing it to generate valid JSON,
 *   it may generate a opening brace `{` but never generate a closing brace `}`. In such cases, the
 *   prediction will go on forever until the context length is reached, which can take a long time.
 *   Therefore, it is recommended to always set a `maxPredictedTokens` limit.
 *
 * @public
 */
export declare type LLMStructuredPredictionSetting = {
    type: "none";
} | {
    type: "json";
    jsonSchema?: any;
};

/**
 * TODO: Documentation
 *
 * @public
 */
export declare type LLMTool = {
    type: "function";
    function: {
        name: string;
        description?: string;
        parameters?: LLMToolParameters;
    };
};

/**
 * TODO: Documentation
 *
 * @public
 */
export declare type LLMToolParameters = {
    type: "object";
    properties: Record<string, any>;
    required?: string[];
    additionalProperties?: boolean;
};

/**
 * TODO: Documentation
 *
 * @public
 */
export declare type LLMToolUseSetting = {
    type: "none";
} | {
    type: "toolArray";
    tools?: LLMTool[];
};

/** @public */
export declare class LMStudioClient {
    readonly clientIdentifier: string;
    readonly llm: LLMNamespace;
    readonly embedding: EmbeddingNamespace;
    readonly system: SystemNamespace;
    readonly diagnostics: DiagnosticsNamespace;
    readonly retrieval: RetrievalNamespace;
    readonly files: FilesNamespace;
    readonly repository: RepositoryNamespace;
    /**
     * The namespace for plugin registration APIs used internally by LM Studio and lms cli. Unless you
     * are writing an alternative external plugin runner, you should not use this namespace.
     *
     * If you are developing a plugin, follow our guide on "".
     */
    readonly plugins: PluginsNamespace;
    private isLocalhostWithGivenPortLMStudioServer;
    /**
     * Guess the base URL of the LM Studio server by visiting localhost on various default ports.
     */
    private guessBaseUrl;
    private createPort;
    private resolvingBaseUrl;
    private verboseErrorMessages;
    constructor(opts?: LMStudioClientConstructorOpts);
}

/** @public */
export declare interface LMStudioClientConstructorOpts {
    /**
     * Changes the logger that is used by LMStudioClient internally. The default logger is `console`.
     * By default, LMStudioClient only logs warnings and errors that require user intervention. If the
     * `verbose` option is enabled while calling supporting methods, those messages will also be
     * directed to the specified logger.
     */
    logger?: LoggerInterface;
    /**
     * The base URL of the LM Studio server. If not provided, LM Studio will attempt to connect to the
     * localhost with various default ports.
     *
     * If you have set a custom port and/or are reverse-proxying, you should pass in the baseUrl.
     *
     * Since LM Studio uses WebSockets, the protocol must be "ws" or "wss".
     *
     * For example, if have changed the port to 8080, you should create the LMStudioClient like so:
     *
     * ```typescript
     * const client = new LMStudioClient({ baseUrl: "ws://127.0.0.1:8080" });
     * ```
     */
    baseUrl?: string;
    /**
     * Whether to include stack traces in the errors caused by LM Studio. By default, this is set to
     * `false`. If set to `true`, LM Studio SDK will include a stack trace in the error message.
     */
    verboseErrorMessages?: boolean;
    /**
     * Changes the client identifier used to authenticate with LM Studio. By default, it uses a
     * randomly generated string.
     *
     * If you wish to share resources across multiple LMStudioClient, you should set them to use the
     * same `clientIdentifier` and `clientPasskey`.
     */
    clientIdentifier?: string;
    /**
     * Changes the client passkey used to authenticate with LM Studio. By default, it uses a randomly
     * generated string.
     *
     * If you wish to share resources across multiple LMStudioClient, you should set them to use the
     * same `clientIdentifier` and `clientPasskey`.
     */
    clientPasskey?: string;
}

/** @public */
export declare interface LoggerInterface {
    info(...messages: Array<unknown>): void;
    error(...messages: Array<unknown>): void;
    warn(...messages: Array<unknown>): void;
    debug(...messages: Array<unknown>): void;
}

/** @public */
export declare type LogLevel = "debug" | "info" | "warn" | "error";

/**
 * Represents some underlying data that may or may not be mutable.
 *
 * @public
 */
export declare abstract class MaybeMutable<Data> {
    protected readonly data: Data;
    protected readonly mutable: boolean;
    protected constructor(data: Data, mutable: boolean);
    /**
     * Gets the class name. This is used for printing errors.
     */
    protected abstract getClassName(): string;
    /**
     * Creates a new instance of the class with the given data.
     */
    protected abstract create(data: Data, mutable: boolean): this;
    /**
     * Clones the data.
     */
    protected abstract cloneData(data: Data): Data;
    asMutableCopy(): this;
    asImmutableCopy(): this;
    protected guardMutable(): void;
}

/**
 * @public
 */
export declare type ModelCompatibilityType = "gguf" | "safetensors" | "onnx" | "ggml" | "mlx_placeholder";

/**
 * Describes a specific loaded LLM.
 *
 * @public
 */
export declare interface ModelDescriptor {
    /**
     * The identifier of the model (Set when loading the model. Defaults to the same as the path.)
     *
     * Identifier identifies a currently loaded model.
     */
    identifier: string;
    /**
     * The path of the model. (i.e. which model is this)
     *
     * An path is associated with a specific model that can be loaded.
     */
    path: string;
}

/**
 * @public
 */
export declare type ModelDomainType = "llm" | "embedding" | "imageGen" | "transcription" | "tts";

/**
 * Abstract namespace for namespaces that deal with models.
 *
 * @public
 */
export declare abstract class ModelNamespace<TLoadModelConfig, TDynamicHandle extends DynamicHandle, TSpecificModel> {
    /**
     * Load a model for inferencing. The first parameter is the model path. The second parameter is an
     * optional object with additional options. By default, the model is loaded with the default
     * preset (as selected in LM Studio) and the verbose option is set to true.
     *
     * When specifying the model path, you can use the following format:
     *
     * `<publisher>/<repo>[/model_file]`
     *
     * If `model_file` is not specified, the first (sorted alphabetically) model in the repository is
     * loaded.
     *
     * To find out what models are available, you can use the `lms ls` command, or programmatically
     * use the `client.system.listDownloadedModels` method.
     *
     * Here are some examples:
     *
     * Loading Llama 3:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF");
     * ```
     *
     * Loading a specific quantization (q4_k_m) of Llama 3:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF/Meta-Llama-3-8B-Instruct-Q4_K_M.gguf");
     * ```
     *
     * To unload the model, you can use the `client.llm.unload` method. Additionally, when the last
     * client with the same `clientIdentifier` disconnects, all models loaded by that client will be
     * automatically unloaded.
     *
     * Once loaded, see {@link LLMDynamicHandle} or {@link EmbeddingDynamicHandle} for how to use the
     * model for inferencing or other things you can do with the model.
     *
     * @param path - The path of the model to load.
     * @param opts - Options for loading the model.
     * @returns A promise that resolves to the model that can be used for inferencing
     */
    load(path: string, opts?: BaseLoadModelOpts<TLoadModelConfig>): Promise<TSpecificModel>;
    /**
     * Unload a model. Once a model is unloaded, it can no longer be used. If you wish to use the
     * model afterwards, you will need to load it with {@link LLMNamespace#loadModel} again.
     *
     * @param identifier - The identifier of the model to unload.
     */
    unload(identifier: string): Promise<void>;
    /**
     * List all the currently loaded models.
     */
    listLoaded(): Promise<Array<ModelDescriptor>>;
    /**
     * Get a specific model that satisfies the given query. The returned model is tied to the specific
     * model at the time of the call.
     *
     * For more information on the query, see {@link ModelQuery}.
     *
     * @example
     *
     * If you have loaded a model with the identifier "my-model", you can use it like this:
     *
     * ```ts
     * const model = await client.llm.get({ identifier: "my-model" });
     * const prediction = model.complete("...");
     * ```
     *
     * Or just
     *
     * ```ts
     * const model = await client.llm.get("my-model");
     * const prediction = model.complete("...");
     * ```
     *
     * @example
     *
     * Use the Gemma 2B IT model (given it is already loaded elsewhere):
     *
     * ```ts
     * const model = await client.llm.get({ path: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF" });
     * const prediction = model.complete("...");
     * ```
     */
    get(query: ModelQuery): Promise<TSpecificModel>;
    /**
     * Get a specific model by its identifier. The returned model is tied to the specific model at the
     * time of the call.
     *
     * @example
     *
     * If you have loaded a model with the identifier "my-model", you can use it like this:
     *
     * ```ts
     * const model = await client.llm.get("my-model");
     * const prediction = model.complete("...");
     * ```
     *
     */
    get(path: string): Promise<TSpecificModel>;
    getAny(): Promise<TSpecificModel>;
    /**
     * Get a dynamic model handle for any loaded model that satisfies the given query.
     *
     * For more information on the query, see {@link ModelQuery}.
     *
     * Note: The returned `LLMModel` is not tied to any specific loaded model. Instead, it represents
     * a "handle for a model that satisfies the given query". If the model that satisfies the query is
     * unloaded, the `LLMModel` will still be valid, but any method calls on it will fail. And later,
     * if a new model is loaded that satisfies the query, the `LLMModel` will be usable again.
     *
     * You can use {@link LLMDynamicHandle#getModelInfo} to get information about the model that is
     * currently associated with this handle.
     *
     * @example
     *
     * If you have loaded a model with the identifier "my-model", you can use it like this:
     *
     * ```ts
     * const dh = client.llm.createDynamicHandle({ identifier: "my-model" });
     * const prediction = dh.complete("...");
     * ```
     *
     * @example
     *
     * Use the Gemma 2B IT model (given it is already loaded elsewhere):
     *
     * ```ts
     * const dh = client.llm.createDynamicHandle({ path: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF" });
     * const prediction = dh.complete("...");
     * ```
     *
     * @param query - The query to use to get the model.
     */
    createDynamicHandle(query: ModelQuery): TDynamicHandle;
    /**
     * Get a dynamic model handle by its identifier.
     *
     * Note: The returned `LLMModel` is not tied to any specific loaded model. Instead, it represents
     * a "handle for a model with the given identifier". If the model with the given identifier is
     * unloaded, the `LLMModel` will still be valid, but any method calls on it will fail. And later,
     * if a new model is loaded with the same identifier, the `LLMModel` will be usable again.
     *
     * You can use {@link LLMDynamicHandle#getModelInfo} to get information about the model that is
     * currently associated with this handle.
     *
     * @example
     *
     * If you have loaded a model with the identifier "my-model", you can get use it like this:
     *
     * ```ts
     * const dh = client.llm.createDynamicHandle("my-model");
     * const prediction = dh.complete("...");
     * ```
     *
     * @param identifier - The identifier of the model to get.
     */
    createDynamicHandle(identifier: string): TDynamicHandle;
    /**
     * Create a dynamic handle from the internal instance reference.
     *
     * @alpha
     */
    createDynamicHandleFromInstanceReference(instanceReference: string): TDynamicHandle;
    /**
     * Get a model by its identifier. If no model is loaded with such identifier, load a model with
     * the given auto identifier. You can find a model's auto identifier by right-clicking the model
     * in My Models page and selecting "Copy Default Identifier".
     *
     */
    getOrLoad(autoIdentifier: string, opts?: BaseLoadModelOpts<TLoadModelConfig>): Promise<TSpecificModel>;
}

/**
 * Represents a query for a loaded LLM.
 *
 * @public
 */
export declare interface ModelQuery {
    /**
     * The domain of the model.
     */
    domain?: ModelDomainType;
    /**
     * If specified, the model must have exactly this identifier.
     *
     * Note: The identifier of a model is set when loading the model. It defaults to the filename of
     * the model if not specified. However, this default behavior should not be relied upon. If you
     * wish to query a model by its path, you should specify the path instead of the identifier:
     *
     * Instead of
     *
     * ```ts
     * const model = client.llm.get({ identifier: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF" });
     * // OR
     * const model = client.llm.get("lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF");
     * ```
     *
     * Use
     *
     * ```ts
     * const model = client.llm.get({ path: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF" });
     * ```
     */
    identifier?: string;
    /**
     * If specified, the model must have this path.
     *
     * When specifying the model path, you can use the following format:
     *
     * `<publisher>/<repo>[/model_file]`
     *
     * If `model_file` is not specified, any quantization of the model will match this query.
     *
     * Here are some examples:
     *
     * Query any loaded Llama 3 model:
     *
     * ```ts
     * const model = client.llm.get({
     *   path: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF",
     * });
     * ```
     *
     * Query any loaded model with a specific quantization of the Llama 3 model:
     *
     * ```ts
     * const model = client.llm.get({
     *   path: "lmstudio-community/Meta-Llama-3-8B-Instruct-GGUF/Meta-Llama-3-8B-Instruct-Q4_K_M.gguf",
     * });
     * ```
     */
    path?: string;
}

/** @public */
export declare interface ModelSearchOpts {
    /**
     * The search term to use when searching for models. If not provided, recommended models will
     * be returned.
     */
    searchTerm?: string;
    /**
     * How many results to return. If not provided, this value will be decided by LM Studio.
     */
    limit?: number;
    /**
     * The model compatibility types to filter by. If not provided, only models that are supported
     * by your current runtimes will be returned.
     */
    compatibilityTypes?: Array<ModelCompatibilityType>;
}

/** @public */
export declare class ModelSearchResultDownloadOption {
    private readonly logger;
    private readonly data;
    readonly quantization?: string;
    readonly name: string;
    readonly sizeBytes: number;
    readonly fitEstimation?: ModelSearchResultDownloadOptionFitEstimation;
    readonly indexedModelIdentifier: string;
    isRecommended(): boolean;
    /**
     * Download the model. Returns a path that can be used to load the model.
     */
    download(opts?: DownloadOpts): Promise<string>;
}

/**
 * @public
 */
export declare type ModelSearchResultDownloadOptionFitEstimation = "fullGPUOffload" | "partialGPUOffload" | "fitWithoutGPU" | "willNotFit";

/** @public */
export declare class ModelSearchResultEntry {
    private readonly logger;
    private readonly data;
    readonly name: string;
    isExactMatch(): boolean;
    isStaffPick(): boolean;
    getDownloadOptions(): Promise<Array<ModelSearchResultDownloadOption>>;
}

/**
 * Represents an ongoing prediction.
 *
 * Note, this class is Promise-like, meaning you can use it as a promise. It resolves to a
 * {@link PredictionResult}, which contains the generated text in the `.content` property. Example
 * usage:
 *
 * ```typescript
 * const result = await model.complete("When will The Winds of Winter be released?");
 * console.log(result.content);
 * ```
 *
 * Or you can use instances methods like `then` and `catch` to handle the result or error of the
 * prediction.
 *
 * ```typescript
 * model.complete("When will The Winds of Winter be released?")
 *  .then(result =\> console.log(result.content))
 *  .catch(error =\> console.error(error));
 * ```
 *
 * Alternatively, you can also stream the result (process the results as more content is being
 * generated). For example:
 *
 * ```typescript
 * for await (const { content } of model.complete("When will The Winds of Winter be released?")) {
 *   process.stdout.write(content);
 * }
 * ```
 *
 * @public
 */
export declare class OngoingPrediction extends StreamablePromise<LLMPredictionFragment, PredictionResult> {
    private readonly onCancel;
    private stats;
    private modelInfo;
    private loadModelConfig;
    private predictionConfig;
    protected collect(fragments: ReadonlyArray<LLMPredictionFragment>): Promise<PredictionResult>;
    private constructor();
    /**
     * Get the final prediction results. If you have been streaming the results, awaiting on this
     * method will take no extra effort, as the results are already available in the internal buffer.
     *
     * Example:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const { content } of prediction) {
     *   process.stdout.write(content);
     * }
     * const result = await prediction.result();
     * console.log(result.stats);
     * ```
     *
     * Technically, awaiting on this method is the same as awaiting on the instance itself:
     *
     * ```typescript
     * await prediction.result();
     *
     * // Is the same as:
     *
     * await prediction;
     * ```
     */
    result(): Promise<PredictionResult>;
    /**
     * Cancels the prediction. This will stop the prediction with stop reason `userStopped`. See
     * {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    cancel(): Promise<void>;
}

/**
 * @public
 */
export declare interface ParsedConfig<TVirtualConfigSchematics extends VirtualConfigSchematics> {
    [configSchematicsBrand]?: TVirtualConfigSchematics;
    get<TKey extends keyof TVirtualConfigSchematics & string>(key: TKey): TVirtualConfigSchematics[TKey]["type"];
}

/**
 * @public
 */
export declare interface PluginContext {
    /**
     * Sets the config schematics associated with this plugin context. Returns the same PluginContext.
     */
    withConfigSchematics: (configSchematics: ConfigSchematics<VirtualConfigSchematics>) => PluginContext;
    /**
     * Sets the generator associated with this plugin context. Returns the same PluginContext.
     */
    withGenerator(generate: Generator_2): PluginContext;
    /**
     * Sets the preprocessor associated with this plugin context. Returns the same PluginContext.
     */
    withPreprocessor(preprocess: Preprocessor): PluginContext;
}

/**
 * @public
 */
export declare interface PluginManifest {
    type: "plugin";
    runner: PluginRunnerType;
    owner: string;
    name: string;
    description: string;
    revision?: number;
}

/**
 * @public
 */
export declare type PluginRunnerType = "ecmascript";

/**
 * @public
 *
 * The namespace for file-related operations. Currently no public-facing methods.
 */
export declare class PluginsNamespace {
    private readonly client;
    private readonly validator;
    private readonly rootLogger;
    registerDevelopmentPlugin(opts: RegisterDevelopmentPluginOpts): Promise<RegisterDevelopmentPluginResult>;
    /**
     * Requests LM Studio to reindex all the plugins.
     *
     * CAVEAT: Currently, we do not wait for the reindex to complete before returning. In the future,
     * we will change this behavior and only return after the reindex is completed.
     */
    reindexPlugins(): Promise<void>;
    /**
     * Sets the preprocessor to be used by the plugin represented by this client.
     */
    setPreprocessor(preprocessor: Preprocessor): void;
    /**
     * Sets the preprocessor to be used by the plugin represented by this client.
     */
    setGenerator(generator: Generator_2): void;
    setConfigSchematics(configSchematics: ConfigSchematics<any>): Promise<void>;
    initCompleted(): Promise<void>;
}

/**
 * Controller for a citation block in the prediction process. Currently cannot do anything.
 *
 * @public
 */
export declare class PredictionProcessCitationBlockController {
    private readonly id;
}

/**
 * @public
 *
 * TODO: Documentation
 */
export declare class PredictionProcessContentBlockController {
    private readonly id;
    appendText(text: string): void;
    replaceText(text: string): void;
    attachGenInfo(genInfo: LLMGenInfo): void;
    pipeFrom(prediction: OngoingPrediction): Promise<PredictionResult>;
}

/**
 * Controller for a debug info block in the prediction process. Currently cannot do anything.
 *
 * @public
 */
export declare class PredictionProcessDebugInfoBlockController {
    private readonly id;
}

/**
 * Controller for a status block in the prediction process.
 *
 * @public
 */
export declare class PredictionProcessStatusController {
    private readonly id;
    private readonly indentation;
    private lastSubStatus;
    private lastState;
    setText(text: string): void;
    setState(state: StatusStepState): void;
    remove(): void;
    private getNestedLastSubStatusBlockId;
    addSubStatus(initialState: StatusStepState): PredictionProcessStatusController;
}

/**
 * Represents the result of a prediction.
 *
 * The most notably property is {@link PredictionResult#content}, which contains the generated text.
 * Additionally, the {@link PredictionResult#stats} property contains statistics about the
 * prediction.
 *
 * @public
 */
export declare class PredictionResult {
    /**
     * The newly generated text as predicted by the LLM.
     */
    readonly content: string;
    /**
     * Statistics about the prediction.
     */
    readonly stats: LLMPredictionStats;
    /**
     * Information about the model used for the prediction.
     */
    readonly modelInfo: ModelDescriptor;
    /**
     * The configuration used to load the model.
     */
    readonly loadConfig: KVConfig;
    /**
     * The configuration used for the prediction.
     */
    readonly predictionConfig: KVConfig;
    constructor(
    /**
     * The newly generated text as predicted by the LLM.
     */
    content: string, 
    /**
     * Statistics about the prediction.
     */
    stats: LLMPredictionStats, 
    /**
     * Information about the model used for the prediction.
     */
    modelInfo: ModelDescriptor, 
    /**
     * The configuration used to load the model.
     */
    loadConfig: KVConfig, 
    /**
     * The configuration used for the prediction.
     */
    predictionConfig: KVConfig);
}

/**
 * TODO: Documentation
 *
 * @public
 */
export declare type Preprocessor = (ctl: PreprocessorController, userMessage: ChatMessage) => Promise<string | ChatMessage>;

/**
 * @public
 */
export declare type PreprocessorController = Omit<ProcessingController, "createContentBlock" | "setSenderName">;

/**
 * @public
 */
export declare class ProcessingController {
    readonly client: LMStudioClient;
    readonly abortSignal: AbortSignal;
    private sendUpdate;
    getPluginConfig<TVirtualConfigSchematics extends VirtualConfigSchematics>(configSchematics: ConfigSchematics<TVirtualConfigSchematics>): ParsedConfig<TVirtualConfigSchematics>;
    /**
     * Gets a mutable copy of the current history. The returned history is a copy, so mutating it will
     * not affect the actual history. It is mutable for convenience reasons.
     *
     * - If you are a preprocessor, this will not include the user message you are currently
     *   preprocessing.
     * - If you are a generator, this will include the user message, and can be fed into the
     *   {@link LLMDynamicHandle#respond} directly.
     */
    pullHistory(): Promise<ChatHistory>;
    createStatus(initialState: StatusStepState): PredictionProcessStatusController;
    addCitations(retrievalResult: RetrievalResult): void;
    addCitations(entries: Array<RetrievalResultEntry>): void;
    createCitationBlock(citedText: string, source: CreateCitationBlockOpts): PredictionProcessCitationBlockController;
    createContentBlock({ includeInContext, label, labelColor, }?: CreateContentBlockOpts): PredictionProcessContentBlockController;
    debug(...messages: Array<any>): void;
    getPredictionConfig(): LLMPredictionConfig;
    readonly model: Readonly<{
        getOrLoad: () => Promise<LLMSpecificModel>;
    }>;
    /**
     * Sets the sender name for this message. The sender name shown above the message in the chat.
     */
    setSenderName(name: string): Promise<void>;
    /**
     * Throws an error if the prediction process has been aborted. Sprinkle this throughout your code
     * to ensure that the prediction process is aborted as soon as possible.
     */
    guardAbort(): void;
    /**
     * Whether this prediction process has had any status.
     */
    hasStatus(): Promise<boolean>;
    /**
     * Returns whether this conversation needs a name.
     */
    needsNaming(): Promise<boolean>;
    /**
     * Suggests a name for this conversation.
     */
    suggestName(name: string): Promise<void>;
}

/**
 * @public
 */
declare interface PushArtifactOpts {
    path: string;
    onMessage?: (message: string) => void;
}

/**
 * @public
 */
export declare interface RegisterDevelopmentPluginOpts {
    manifest: PluginManifest;
}

export declare interface RegisterDevelopmentPluginResult {
    clientIdentifier: string;
    clientPasskey: string;
    unregister: () => Promise<void>;
}

/** @public */
export declare class RepositoryNamespace {
    private readonly repositoryPort;
    private readonly validator;
    searchModels(opts: ModelSearchOpts): Promise<Array<ModelSearchResultEntry>>;
    installPluginDependencies(pluginFolder: string): Promise<void>;
    downloadArtifact(opts: DownloadArtifactOpts): Promise<void>;
    pushArtifact(opts: PushArtifactOpts): Promise<void>;
    ensureAuthenticated(opts: EnsureAuthenticatedOpts): Promise<void>;
}

/**
 * @public
 */
export declare interface RetrievalCallbacks {
    /**
     * Callback when the list of files to process is available. This list can be shorter than the list
     * passed in because some files may already have cached embeddings.
     *
     * @param filePathsToProcess - The list of files that will be processed.
     */
    onFileProcessList?: (filesToProcess: Array<FileHandle>) => void;
    /**
     * Callback when starting to process a file.
     *
     * @param file - The file being processed.
     * @param index - The index of the file in the list of files to process.
     * @param filePathsToProcess - The list of files that will be processed. This will be the same as
     * the list passed to `onFileProcessList`.
     */
    onFileProcessingStart?: (file: FileHandle, index: number, filesToProcess: Array<FileHandle>) => void;
    /**
     * Callback when processing a file has ended.
     *
     * @param file - The file that has been processed.
     * @param index - The index of the file in the list of files to process.
     * @param filePathsToProcess - The list of files that will be processed. This will be the same as
     * the list passed to `onFileProcessList`.
     */
    onFileProcessingEnd?: (file: FileHandle, index: number, filesToProcess: Array<FileHandle>) => void;
    /**
     * Callback when starting a processing step for a file. LM Studio process files one at a time and
     * processing each file involves multiple steps. This callback is called when starting a step.
     *
     * @param file - The file being processed.
     * @param step - The step being started.
     */
    onFileProcessingStepStart?: (file: FileHandle, step: RetrievalFileProcessingStep) => void;
    /**
     * Granular progress callback for a processing step.
     *
     * @param file - The file being processed.
     * @param step - The step being started.
     * @param progressInStep - The progress in the step for the step. This value is between 0 and 1.
     */
    onFileProcessingStepProgress?: (file: FileHandle, step: RetrievalFileProcessingStep, progressInStep: number) => void;
    /**
     * Callback when a processing step has ended.
     *
     * @param file - The file being processed.
     * @param step - The step that has ended.
     */
    onFileProcessingStepEnd?: (file: FileHandle, step: RetrievalFileProcessingStep) => void;
    /**
     * Callback when we have embedded all the files and are starting to search in the vector database.
     */
    onSearchingStart?: () => void;
    /**
     * Callback when we have finished searching in the vector database. The chunk usually will be
     * returned immediately after this callback.
     */
    onSearchingEnd?: () => void;
    /**
     * Controls the logging of retrieval progress.
     *
     * - If set to `true`, logs progress at the "info" level.
     * - If set to `false`, no logs are emitted. This is the default.
     * - If a specific logging level is desired, it can be provided as a string. Acceptable values are
     *   "debug", "info", "warn", and "error".
     *
     * Logs are directed to the logger specified during the `LMStudioClient` construction.
     *
     * Progress logs will be disabled if any of the callbacks are provided.
     *
     * Default value is "info", which logs progress at the "info" level.
     */
    verbose?: boolean | LogLevel;
}

/**
 * @public
 */
export declare interface RetrievalChunk {
    content: string;
    score: number;
    citation: CitationSource;
}

/**
 * @public
 */
export declare type RetrievalChunkingMethod = {
    type: "recursive-v1";
    chunkSize: number;
    chunkOverlap: number;
};

/**
 * @public
 */
export declare type RetrievalFileProcessingStep = "loading" | "chunking" | "embedding";

/** @public */
export declare class RetrievalNamespace {
    private readonly retrievalPort;
    private readonly validator;
    private readonly embeddingNamespace;
    retrieve(query: string, files: Array<FileHandle>, opts?: RetrievalOpts): Promise<RetrievalResult>;
}

/**
 * @public
 * N.B.: onProgress returns progress as a float taking values from 0 to 1, 1 being completed
 */
export declare type RetrievalOpts = RetrievalCallbacks & {
    /**
     * The chunking method to use. By default uses recursive-v1 with chunk size 512 and chunk overlap
     * 100.
     */
    chunkingMethod?: RetrievalChunkingMethod;
    /**
     * The number of results to return.
     */
    limit?: number;
    /**
     * The embedding model to use.
     */
    embeddingModel?: EmbeddingDynamicHandle;
    /**
     * The path to the database.
     */
    databasePath?: string;
    /**
     * The signal to abort the retrieval
     */
    signal?: AbortSignal;
};

/** @public */
export declare interface RetrievalResult {
    entries: Array<RetrievalResultEntry>;
}

/** @public */
export declare interface RetrievalResultEntry {
    content: string;
    score: number;
    source: FileHandle;
}

/**
 * @public
 */
export declare interface SpecificModel extends DynamicHandle {
    readonly identifier: string;
    readonly path: string;
}

/**
 * @public
 */
export declare interface StatusStepState {
    status: StatusStepStatus;
    text: string;
}

/**
 * @public
 */
export declare type StatusStepStatus = "waiting" | "loading" | "done" | "error" | "canceled";

/**
 * A StreamablePromise is a promise-like that is also async iterable. This means you can use it as a
 * promise (awaiting it, using `.then`, `.catch`, etc.), and you can also use it as an async
 * iterable (using `for await`).
 *
 * Notably, as much as it implements the async iterable interface, it is not a traditional iterable,
 * as it internally maintains a buffer and new values are pushed into the buffer by the producer, as
 * oppose to being pulled by the consumer.
 *
 * The async iterable interface is used instead of the Node.js object stream because streams are too
 * clunky to use, and the `for await` syntax is much more ergonomic for most people.
 *
 * If any iterator is created for this instance, an empty rejection handler will be attached to the
 * promise to prevent unhandled rejection warnings.
 *
 * This class is provided as an abstract class and is meant to be extended. Crucially, the `collect`
 * method must be implemented, which will be called to convert an array of values into the final
 * resolved value of the promise.
 *
 * In addition, the constructor of the subclass should be marked as private, and a static method
 * that exposes the constructor, the `finished` method, and the `push` method should be provided.
 *
 * @typeParam TFragment - The type of the individual fragments that are pushed into the buffer.
 * @typeParam TFinal - The type of the final resolved value of the promise.
 * @public
 */
export declare abstract class StreamablePromise<TFragment, TFinal> implements Promise<TFinal>, AsyncIterable<TFragment> {
    protected abstract collect(fragments: ReadonlyArray<TFragment>): Promise<TFinal>;
    private promiseFinal;
    private resolveFinal;
    private rejectFinal;
    protected status: "pending" | "resolved" | "rejected";
    private buffer;
    private nextFragmentPromiseBundle;
    /**
     * If there has ever been any iterators created for this instance. Once any iterator is created,
     * a reject handler will be attached to the promise to prevent unhandled rejection warnings, as
     * the errors will be handled by the iterator.
     *
     * The purpose of this variable is to prevent registering the reject handler more than once.
     */
    private hasIterator;
    /**
     * Called by the producer when it has finished producing values. If an error is provided, the
     * promise will be rejected with that error. If no error is provided, the promise will be resolved
     * with the final value.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param error - The error to reject the promise with, if any.
     */
    protected finished(error?: any): void;
    /**
     * Called by the producer to push a new fragment into the buffer. This method should be exposed in
     * the static constructor of the subclass.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param fragment - The fragment to push into the buffer.
     */
    protected push(fragment: TFragment): void;
    protected constructor();
    then<TResult1 = TFinal, TResult2 = never>(onfulfilled?: ((value: TFinal) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<TFinal | TResult>;
    finally(onfinally?: (() => void) | null | undefined): Promise<TFinal>;
    [Symbol.toStringTag]: string;
    /**
     * If nextFragmentPromiseBundle exists, it is returned. Otherwise, a new one is created and
     * returned.
     */
    private obtainNextFragmentPromiseBundle;
    [Symbol.asyncIterator](): AsyncIterator<TFragment, any, undefined>;
}

/** @public */
export declare class SystemNamespace {
    private readonly systemPort;
    private readonly validator;
    /**
     * List all downloaded models.
     * @public
     */
    listDownloadedModels(): Promise<Array<DownloadedModel>>;
    whenDisconnected(): Promise<void>;
    notify(notification: BackendNotification): Promise<void>;
}

/**
 * @public
 */
export declare type VirtualConfigSchematics = {
    [key: string]: {
        key: string;
        type: any;
        valueTypeKey: string;
    };
};

export { }
